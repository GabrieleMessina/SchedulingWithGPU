\documentclass[../relazione.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}

\begin{document}
\section{Implementazione}
\subsection{SDK}
Per l'implementazione in parallelo si è deciso di usare OpenCL per la possibilità di eseguire il codice su più piattaforme.
\subsection{Struttura DAG}
In memoria la DAG è composta da una matrice di adiacenza in cui ogni edge (i,j) indica che i è un padre di j.

Si mantiene inoltre un array di nodes in cui l'indice corrisponde all'id del task e il valore della cella indica il peso del task.

\subsection{Prima implementazione}
\begin{enumerate}
\item  si cercano le entries, cioè tutti i task "root" che quindi non hanno nessun parent.
\item a partire dalle entry, si calcolano le metriche di questi task e successivamente si inseriscono le task dipendenti o "figlie" in coda in modo da ripetere ripetere questo punto fino a quando tutte le metriche sono state calcolate.
\item a partire dalle metriche i task vengono ordinati in modo da decidere l'ordine di esecuzione degli stessi.
\end{enumerate}
\subsubsection{Difficoltà}
Alcuni task hanno più di una dipendenza, per cui è stato necessario mettere in coda i task solo dopo che tutti i parent avessero calcolato la propria metrica.
Inoltre la coda andava azzerata ad ogni ciclo.

\subsection{Seconda implementazione}
Si è deciso di provare a vettorizzare la coda dei task in modo da gestirne più di uno contemporaneamente.
\begin{enumerate}
\item  si cercano le entries, cioè tutti i task "root" che quindi non hanno nessun parent.
\item a partire dalle entry, si calcolano le metriche di questi task e successivamente si inseriscono le task dipendenti o "figlie" in coda in modo da ripetere ripetere questo punto fino a quando tutte le metriche sono state calcolate.
\item a partire dalle metriche i task vengono ordinati in modo da decidere l'ordine di esecuzione degli stessi.
\end{enumerate}
\subsubsection{Difficoltà}
In aggiunta alle difficoltà precedenti è stato necessario gestire anche la vettorizzazione.

\subsection{Terza implementazione}
Si è provato ad usare una matrice di adiacenza trasposta per verificare se questo poteva incidere positivamente sulle prestazioni, implementandola anche nel caso di coda vettorizzata.

\subsection{Quarta implementazione}
Si è provato ad usare due matrici rettangolari di adiacenza una in cui ogni colonna i-esima indica i parent del task i-esimo e l'altra che invece in ogni colonna contiene i child del task, implementandola anche nel caso di coda vettorizzata.
\end{document}