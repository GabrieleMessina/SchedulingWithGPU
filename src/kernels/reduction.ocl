#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable
#include "../app_globals.h"

int matrix_to_array_indexes(int i, int j, int row_len){
	return i * row_len + j;
}


void print(global metrics_tt* v, int len, bool withIndexes) {
	for (int i = 0; i < len; i++)
	{
		if (withIndexes)
			printf("%d:", i);
		printf("%d - %d - ", v[i].x, v[i].y);
	}

	printf("\n");
}

kernel void reduce_queue(global int* restrict output, const global int2* restrict input,
	local int* restrict lmem,
	int npairs)
{
	const int global_index = get_global_id(0);

	//if(global_index == 0)print(input, npairs, false);

	int2 pair = global_index < npairs ? input[global_index] : (int2)(0, 0);

	const int local_index = get_local_id(0);

	bool value = (pair.x > 0) || (pair.y > 0);
	lmem[local_index] = value;

	for (int stride = get_local_size(0) / 2; stride > 0; stride /= 2) {
		barrier(CLK_LOCAL_MEM_FENCE);
		if (value != 0) continue;
		if (local_index < stride) {
			value |= lmem[local_index + stride] > 0;
			lmem[local_index] = value;
		}
	}

	if (local_index == 0)
		output[get_group_id(0)] = value;
	
		
	//if(global_index == 0)print(output, npairs, false);
}

kernel void compute_processor_cost(
	const int current_node, 
	global edge_t* restrict edges, 
	global edge_t* restrict predecessors, 
	global edge_t* restrict costs, 
	const int max_edges_dept, 
	global int3* restrict output, 
	global int3* restrict task_processor_assignment, 
	global int* restrict processorsNextSlotStart, 
	const int len, 
	const int number_of_processors, 
	const int predecessor_with_max_aft, 
	const int weight_for_max_aft_predecessor, 
	const int processor_for_max_aft_predecessor, 
	const int cost_of_predecessors_in_different_processors, 
	const int max_aft_of_predecessors){
	
	
	const int processor = get_global_id(0);

	if(processor >= number_of_processors) return;

	int cost_on_processor = costs[matrix_to_array_indexes(current_node, processor, number_of_processors)];
	int cost_of_predecessor_in_same_processor = 0;
	if (processor_for_max_aft_predecessor == processor) {
		cost_of_predecessor_in_same_processor = weight_for_max_aft_predecessor;
	}

	int remaining_transfer_cost = max(max_aft_of_predecessors - cost_of_predecessor_in_same_processor, cost_of_predecessors_in_different_processors);

	//finalmente posso aggiungere l'eft al task.
	int est = max(processorsNextSlotStart[processor], remaining_transfer_cost);
	int eft = est + cost_on_processor;
	output[processor] = (int3)(processor, est, eft); 
}